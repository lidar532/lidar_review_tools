# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/Lidar_tools.ipynb.

# %% auto 0
__all__ = ['ms2knots', 'm2ft', 'ft2m', 'deg2rad', 'rad2deg', 'las2datetime', 'swath_width', 'DATA', 'TEST_AREA', 'data',
           'profile_distance', 'gen_plot', 'plot_hists', 'show_attributes', 'gen_stats', 'gen_all_stats']

# %% ../nbs/Lidar_tools.ipynb 4
import datetime  as dt
import haversine as hs
import math      as  m
import numpy     as np
import pandas    as pd

from bokeh.layouts      import gridplot
from bokeh.palettes     import HighContrast3
from bokeh.plotting     import figure, show
from bokeh.io           import output_notebook
from bokeh.models       import Span, VSpan
from bokeh.models       import ColumnDataSource, NumeralTickFormatter, HoverTool
from . import ww_bokeh as wwbk

# %% ../nbs/Lidar_tools.ipynb 6
ms2knots   = 1.94384
m2ft       = 3.28084
ft2m       = 1/m2ft
deg2rad    = np.pi/180.0
rad2deg    = 180.0/np.pi

# %% ../nbs/Lidar_tools.ipynb 8
def las2datetime( 
    las_time   # LAS Time 
) ->object:    # UTC_datetime
    """
    Convert a LAS / LAZ time to utc datetime value.
    """
    laz_tools_time_offset = 1e9                                                      # 1e9 that laz-tools subtracted.
    gps_start_epoch       = np.datetime64('1980-01-06', 's')                         # GPS starting epoch in seconds
    czmil_gps_time_stamp  = czmil_time_stamp + gps_start_epoch.astype(int)
    utc_soe = czmil_time_stamp + laz_tools_time_offset + gps_start_epoch.astype(int)
    utc_time = dt.datetime.fromtimestamp(utc_soe)
    return utc_time

# %% ../nbs/Lidar_tools.ipynb 12
def swath_width( 
                full_scan_angle_d:float, # Full scan angle in degrees.
                altitude_ft=None,        # Sensor altitude in feet.
                altitude_m=None          # Sensor altitude in meters.
               ) -> float:               # Returns the swath width in meters.
  """
  Compute the scan width give the full scan angle in degrees, and the altitude in either meters
  or feet.  Returns scan width in meters.
  """
  if altitude_ft is not None:
    altitude_m = altitude_ft * ft2m
  elif altitude_m is not None:
    altitude_ft = altitude_m * m2ft
  else:
    rv = None
  if altitude_m is not None:
    rv = 2 * np.tan( full_scan_angle_d * 0.5 * deg2rad ) * altitude_m
  return rv

# %% ../nbs/Lidar_tools.ipynb 16
class DATA():
    """
    This class gets populated 
    """
    def __init__(self):
        pass

# %% ../nbs/Lidar_tools.ipynb 18
class TEST_AREA():
    """
    Presets parameters for analysis. Most of the parameters are presets for Bokeh
    plots used in the analysis.  Additional attributes to define datasets and 
    their related attributes are added after this class is instantiated.
    """
    def __init__(self):
        self.title                            = 'Title Not set'
        self.y_axis_label                     = 'not Set'
        self.xaxis_axis_label                 = "NAVD88 Depth (m)"
        self.bin_size                         = 0.01
        self.width                            = 700
        self.height                           = 400
        self.axis_axis_label_text_font_style  = 'bold'
        self.axis_axis_label_text_font_size   = "18pt"
        self.title_text_font_size             = "24pt"
        self.title_text_font_style            = "bold"
        self.axis_major_label_text_font_size  = "16pt"
        self.axis_major_label_text_font_style = "bold"
        self.area_width                       = 0
        self.area_length                      = 0
        self.area                             = 0
        self.data_list                        = []
        self.ref_mean                         = None
        self.colab                            = 'google.colab' in str(get_ipython())

        # Generate the Histogram values.
        self.density = False
        if self.density:
            self.yaxis_axis_label = "Normilized Hits/bin"
        else:
            self.yaxis_axis_label = "Number of Depths"


# %% ../nbs/Lidar_tools.ipynb 23
def data( 
    tdf,             # The parent `TEST_AREA` class.
    fn     ='',      # Data file name
    name   = '',     # Name of this data set
    ref    = False,  # Use as the reference dataset or not.
    scale  = 1.0,    # Scale factor.
    offset = 0.0,    # Offset to apply.
    color  = "blue",
    width  = 3,      # line width
):
    """
    Reads the ASCII data file `cls.fn`, stores the data in `cls.df`, and generates stats
    on the `cls.['ELEVATION']` data.  It also generates a histogram, `cls.hist`, based on `tdf.bin_size`.
    """
    cls        = DATA( )
    cls.parent = tdf
    cls.fn     = fn
    cls.name   = name
    cls.ref    = ref
    cls.offset = offset
    cls.color  = color
    cls.width  = width
    cls.df     = pd.read_csv( cls.fn )
    cls.scale  = scale
    elev       = cls.df['ELEVATION'] = (cls.df['ELEVATION']  + offset) * scale
    cls.mean   = elev.mean()
    cls.std    = elev.std()
    cls.min    = elev.min()
    cls.max    = elev.max()
    cls.p2p    = cls.max - cls.min
    cls.nbins  = int(cls.p2p / tdf.bin_size) + 1
    cls.bins   = np.linspace( cls.min, cls.max, cls.nbins )
    cls.number_of_points = elev.shape[0]
    cls.hist, junk = np.histogram( elev, density = tdf.density, bins = cls.bins)
    if tdf.area >0:
        cls.ppm = cls.number_of_points / tdf.area
    else:
        cls.ppm = 0.0;
    tdf.data_list.append( cls )
    #return cls

# %% ../nbs/Lidar_tools.ipynb 26
def profile_distance( df,     # Dataframe or numpy array containing latitude, Longititude, and Elevation columns
                 lat='lat',   # The name of the latitude column
                 lon='lon',   # The name of the Longititude column
                 dist='dist'  # Computed distance value
                ) -> object:  # New dataframe with a new column for distance
  """
  Generate distance values between the first Lat/Lon point and each other Lat/Lon point in the
  DataFrame.
  """
  starting_point = (df[ lat ][0], df[ lon ][0] )
  def gd( row ):
    p =  (row[ lat ], row[ lon ])
    distv = hs.haversine(starting_point, (row[ lat ], row[ lon ]), unit = hs.Unit.METERS)
    row[ dist ] = distv
    return row
    
  rv = df.apply(gd, axis=1 )  # Generate distance values
  return rv

# %% ../nbs/Lidar_tools.ipynb 33
def gen_plot( 
    test_area   # Generate and configure a Bokeh plot.
):
    """
    Generate a plot figure, and store it as an attribute in `test-area`. Configure it with preferred settings.
    """
    # Format the tooltip
    tooltips = [
                ('Depth', '$x')  
               ]
    test_area.p = figure(width=test_area.width, height=test_area.height, title = test_area.title )
    test_area.p.axis.axis_label_text_font_style  = test_area.axis_axis_label_text_font_style
    test_area.p.axis.axis_label_text_font_size   = test_area.axis_axis_label_text_font_size
    test_area.p.title.text_font_size             = test_area.title_text_font_size
    test_area.p.title.text_font_style            = test_area.title_text_font_style
    test_area.p.axis.major_label_text_font_size  = test_area.axis_major_label_text_font_size
    test_area.p.axis.major_label_text_font_style = test_area.axis_major_label_text_font_style
    test_area.p.y_range.start                    = 0
    test_area.p.xaxis.axis_label                 = test_area.xaxis_axis_label
    test_area.p.yaxis.axis_label                 = test_area.yaxis_axis_label
    test_area.p.add_tools(HoverTool(tooltips=tooltips))

# %% ../nbs/Lidar_tools.ipynb 35
def plot_hists( 
    obj         # Data object.
):
    """
    Plot histograms of each dataset.
    """
    output_notebook()           # Enable notebook for Bokeh output.
    gen_plot( obj )
    for i in obj.data_list:
        obj.p.line( 
            i.bins[0:-1],  
            i.hist, 
            legend_label=i.name,  
            line_width = i.width, 
            color = i.color )
        g = VSpan( x = i.mean, line_color = i.color , line_alpha=.5)
        obj.p.add_glyph(g)
    show(obj.p)  

# %% ../nbs/Lidar_tools.ipynb 37
def show_attributes( obj ):
    """
    Printout atrributes of `obj`.  `obj` is a class `DATA`.
    """
    # Show each data set.
    for i in obj.data_list:
        print(
            f'{i.fn:>35s} {i.name:>16s} {i.offset:6.2f}'
            f'{i.mean:6.2f} {i.max-i.min:6.2f}'
            f'{i.color:>8s} {i.width:3d} '
            f'{i.bins[1]-i.bins[0]:6.4f} '
            f'{i.ref}  '
        )

# %% ../nbs/Lidar_tools.ipynb 39
def gen_stats( 
    data_obj=None,       # The data obj 
    header:bool=False,   # Print a header showing the column names.
    area=0               # The area (in meters) that the values came from.  Used to computed points per meter.
) ->tuple:               # Tuple containing: mean, std, min, max, number_of_points
    """
    Print the statistics for the given elevation data from data_obj. Setting header=True will cause it to 
    print a header describing the columns before printing the results.
    """
    ppm_header = "Points/m"
    if header:
        print(
            f"                        Ref            Std                                 Total\n"
            f"    Data Source  Ref    Dif  Mean(m)  Dev(m)   Min(m)    Max(m)   P2P(m)  Points  {ppm_header}  Scale  Offset(m)"
        )
    else:
        values = data_obj.df['ELEVATION']
        mean = values.mean()
        std  = values.std()
        min  = values.min()
        max  = values.max()
        p2p  = max - min
        number_of_points = values.shape[0]

        if data_obj.ref:
            ref = "<--"
            data_obj.parent.ref_mean = mean
        else:
            ref = "   "

        if data_obj.parent.ref_mean:
            ref_dif = f'{data_obj.parent.ref_mean - mean:7.3f}'
        else:
            ref_dif = f' xxxxxx '
    
        if area >0:
            show_ppm = True
            ppm_header = "Points/m"
            ppm        = number_of_points / area
            ppm_s      = f"{ppm:8.3f}"
        else:
            ppm_header = ''
            ppm_s      = ''
    
        print(
            f'{data_obj.name:>15s} '
            f'{ref:3s} '
            f'{ref_dif:6s} '
            f'{mean:6.3f}  {std:7.3f} {min:8.3f}  {max:8.3f} '
            f'{p2p:8.3f} {number_of_points:7d}  {ppm_s}  {data_obj.scale:5.4f} '
            f'{data_obj.offset:5.3f}' 
        )
        return mean, std, min, max, number_of_points

# %% ../nbs/Lidar_tools.ipynb 41
def gen_all_stats( 
    ta:object   # Object of class `TEST_AREA`.
):
    """
    Generate stats for all of the datasets within the `ta` class.
    """
    print(f"\nThe test area is {ta.area:2.1f} square meters. ({ta.area_width} by {ta.area_length} meters)\n")
    gen_stats( header=True)
    for i in ta.data_list:
        #gen_stats(values=i.df['ELEVATION'], name=i.name, area=hx4_a.area)
        gen_stats(data_obj=i,  area=ta.area)
